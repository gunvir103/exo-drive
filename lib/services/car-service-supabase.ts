import { handleSupabaseError } from "@/lib/supabase/client"
// No longer needed as we'll use the browser client in the form
// import { createSupabaseServerClient, createSupabaseServiceRoleClient } from "@/lib/supabase/server"
// import { cookies } from 'next/headers' // Not directly used in service logic now
import { BUCKET_NAMES } from "@/lib/supabase/storage-service"
import type { SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '@/lib/types/database.types' // Import generated types

// Type definitions based on the actual schema from list_tables
// Assuming standard foreign key 'car_id' and primary key 'id' (uuid)

// Base Car Type (from 'cars' table)
export type CarBase = Omit<Database['public']['Tables']['cars']['Row'], 'created_at' | 'updated_at'> & {
    createdAt?: string | null; // Keep original strings for now, convert later if needed
    updatedAt?: string | null;
};

// Related Data Types
export type CarPricing = Database['public']['Tables']['car_pricing']['Row'];
export type CarImage = Database['public']['Tables']['car_images']['Row'];
export type CarFeature = Database['public']['Tables']['car_features']['Row'];
export type CarSpecification = Database['public']['Tables']['car_specifications']['Row'];

// Composite Application Car Type
// Combines base car with related data
export type AppCar = CarBase & {
    pricing: CarPricing | null; // Assuming one-to-one pricing for simplicity, adjust if needed
    images: CarImage[];
    features: CarFeature[];
    specifications: CarSpecification[];
};

// Type for creating/updating (omit IDs generated by DB)
export type CarInsertData = Omit<Database['public']['Tables']['cars']['Insert'], 'id' | 'created_at' | 'updated_at'>;
export type PricingInsertData = Omit<Database['public']['Tables']['car_pricing']['Insert'], 'id' | 'car_id' | 'created_at' | 'updated_at'>;
export type ImageInsertData = Omit<Database['public']['Tables']['car_images']['Insert'], 'id' | 'car_id' | 'created_at'>;
export type FeatureInsertData = Omit<Database['public']['Tables']['car_features']['Insert'], 'id' | 'car_id' | 'created_at'>;
export type SpecificationInsertData = Omit<Database['public']['Tables']['car_specifications']['Insert'], 'id' | 'car_id' | 'created_at'>;

// Composite type for form submission / service input
// Remove fields not in cars.Insert/Update: make, model, year, engine, transmission, drivetrain
export type AppCarUpsert = {
    name: string; // Required for slug generation
    // make?: string | null; // Belongs in specs?
    // model?: string | null; // Belongs in specs?
    // year?: number | null; // Belongs in specs?
    category: string;
    description?: string | null; // Nullable string allowed
    short_description?: string | null; // Nullable string allowed
    // engine?: string | null; // Belongs in specs?
    // transmission?: string | null; // Belongs in specs?
    // drivetrain?: string | null; // Belongs in specs?
    available?: boolean | null; // Nullable boolean allowed
    featured?: boolean | null; // Nullable boolean allowed
    hidden?: boolean | null; // Nullable boolean allowed
    // Related data
    pricing: PricingInsertData;
    images: ImageInsertData[];
    features: FeatureInsertData[];
    specifications: SpecificationInsertData[];
};


// --- Helper Functions (Transformation logic removed as we use related tables directly) ---
// No longer needed as we fetch joined data or assemble it


// --- Service Object ---
export const carServiceSupabase = {
    /**
     * Get *base* car data by ID (Internal helper or basic fetch)
     * Fetches only from the 'cars' table.
     */
    _getBaseCarById: async (supabase: SupabaseClient, id: string): Promise<CarBase | null> => {
        try {
            const { data, error } = await supabase
                .from("cars")
                .select("*")
                .eq("id", id)
                .maybeSingle<CarBase>();

            if (error) throw error;
            return data;
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching base car by ID");
        }
    },

    /**
     * Get *base* car data by Slug (Internal helper or basic fetch)
     * Fetches only from the 'cars' table.
     */
     _getBaseCarBySlug: async (supabase: SupabaseClient, slug: string): Promise<CarBase | null> => {
        try {
            const { data, error } = await supabase
                .from("cars")
                .select("*")
                .eq("slug", slug)
                .maybeSingle<CarBase>();

            if (error) throw error;
            return data;
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching base car by slug");
        }
    },


    /**
     * Get a complete car with all related data by ID (Used by Edit Page, etc.)
     */
    getCarById: async (supabase: SupabaseClient, id: string): Promise<AppCar | null> => {
        try {
            // Fetch base car data
            const { data: carData, error: carError } = await supabase
                .from("cars")
                .select(`
                    *,
                    pricing:car_pricing(*),
                    images:car_images(*),
                    features:car_features(*),
                    specifications:car_specifications(*)
                `)
                .eq("id", id)
                .maybeSingle(); // Use maybeSingle to handle null case gracefully


            if (carError) throw carError;
            if (!carData) return null;

            // Supabase types might be slightly off for nested selects, cast carefully
            const typedCarData = carData as any; // Use any temporarily, refine if needed

            // Assemble the AppCar object
            const assembledCar: AppCar = {
                ...typedCarData, // Spread base car fields
                pricing: Array.isArray(typedCarData.pricing) ? typedCarData.pricing[0] || null : typedCarData.pricing || null, // Handle potential array/single object
                images: typedCarData.images || [],
                features: typedCarData.features || [],
                specifications: typedCarData.specifications || [],
                // Ensure boolean fields have defaults if null
                available: typedCarData.available ?? true,
                featured: typedCarData.featured ?? false,
                hidden: typedCarData.hidden ?? false,
            };

             // Sort images by sort_order if the field exists
             if (assembledCar.images.length > 0 && 'sort_order' in assembledCar.images[0]) {
                assembledCar.images.sort((a, b) => (a.sort_order ?? 0) - (b.sort_order ?? 0));
             }


            return assembledCar;
        } catch (error) {
            console.error("Error in getCarById:", error);
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching car by ID");
        }
    },


    /**
     * Get a complete car with all related data by Slug (Used by Public Fleet Page)
     */
    getCarBySlug: async (supabase: SupabaseClient, slug: string): Promise<AppCar | null> => {
        try {
            // Fetch base car data and related data using joins/selects
             const { data: carData, error: carError } = await supabase
                .from("cars")
                .select(`
                    *,
                    pricing:car_pricing(*),
                    images:car_images(*),
                    features:car_features(*),
                    specifications:car_specifications(*)
                `)
                .eq("slug", slug)
                .maybeSingle(); // Use maybeSingle


            if (carError) throw carError;
            if (!carData) return null;

            // Assemble the AppCar object (similar to getCarById)
             const typedCarData = carData as any;
             const assembledCar: AppCar = {
                ...typedCarData,
                pricing: Array.isArray(typedCarData.pricing) ? typedCarData.pricing[0] || null : typedCarData.pricing || null,
                images: typedCarData.images || [],
                features: typedCarData.features || [],
                specifications: typedCarData.specifications || [],
                available: typedCarData.available ?? true,
                featured: typedCarData.featured ?? false,
                hidden: typedCarData.hidden ?? false,
            };

             // Sort images by sort_order
             if (assembledCar.images.length > 0 && 'sort_order' in assembledCar.images[0]) {
                assembledCar.images.sort((a, b) => (a.sort_order ?? 0) - (b.sort_order ?? 0));
             }

            return assembledCar;
        } catch (error) {
            console.error("Error in getCarBySlug:", error);
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching car by slug");
        }
    },

    /**
     * Get base details for all cars (for Admin List)
     * Includes minimal related data (e.g., primary image URL, price)
     */
    getAllCarsForAdminList: async (supabase: SupabaseClient): Promise<any[]> => { // Return type depends on exact data needed
        try {
            // Select base car data and only essential related fields
            const { data, error } = await supabase
                .from("cars")
                .select(`
                    id,
                    slug,
                    name,
                    category,
                    available,
                    featured,
                    hidden,
                    created_at,
                    pricing:car_pricing(base_price),
                    images:car_images(url, is_primary, sort_order)
                `)
                .order("created_at", { ascending: false });

            if (error) {
                // Throw the specific Supabase error for better debugging upstream
                console.error("Error in getAllCarsForAdminList Query:", error);
                throw error; 
            }

            // Process data to get primary image and price
             return data.map((car: any, index: number) => {
                 // --- DEBUG LOGGING inside map --- 
                 console.log(`Processing car index ${index}, ID: ${car?.id}`);
                 console.log(`  Raw car object:`, JSON.stringify(car, null, 2));
                 console.log(`  car.images type: ${typeof car.images}, isArray: ${Array.isArray(car.images)}`);
                 console.log(`  car.pricing type: ${typeof car.pricing}`);
                 // ----------------------------------
                 
                 let primaryImage = null;
                 try {
                     primaryImage = car.images?.sort((a:any,b:any) => (a.sort_order ?? 0) - (b.sort_order ?? 0)).find((img: any) => img.is_primary) || car.images?.[0];
                 } catch (e) {
                     console.error(`Error processing images for car ID ${car?.id}:`, e);
                 }

                 let price = null;
                 try {
                    // Check if pricing is array or object due to potential Supabase join inconsistency
                    if(Array.isArray(car.pricing)) {
                        price = car.pricing?.[0]?.base_price;
                    } else if (typeof car.pricing === 'object' && car.pricing !== null) {
                        price = car.pricing?.base_price;
                    }
                 } catch (e) {
                      console.error(`Error processing pricing for car ID ${car?.id}:`, e);
                 }
                 
                 // --- DEBUG LOGGING after processing --- 
                 console.log(`  Processed primaryImage URL: ${primaryImage?.url}`);
                 console.log(`  Processed price: ${price}`);
                 // ------------------------------------

                 return {
                    ...car,
                    images: undefined, // remove nested array
                    pricing: undefined, // remove nested array/object
                    primary_image_url: primaryImage?.url,
                    price_per_day: price // Rename for consistency if needed elsewhere
                 };
             });

        } catch (error) {
            console.error("Error in getAllCarsForAdminList:", error);
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching cars for admin list");
        }
    },


    /**
     * Get visible cars for the public fleet (Optimized fetch)
     * Includes necessary data for display (name, slug, price, primary image, category)
     */
    getVisibleCarsForFleet: async (supabase: SupabaseClient): Promise<any[]> => {
         try {
            const { data, error } = await supabase
                .from("cars")
                .select(`
                    id,
                    slug,
                    name,
                    category,
                    short_description,
                    featured,
                    pricing:car_pricing(base_price),
                    images:car_images(url, is_primary, sort_order)
                `)
                .eq("available", true)
                .eq("hidden", false)
                .order("featured", { ascending: false }) // Order by featured first
                .order("created_at", { ascending: false });

            if (error) {
                // Throw the specific Supabase error for better debugging upstream
                console.error("Error in getVisibleCarsForFleet Query:", error);
                throw error; 
            }

            // Process data (similar to admin list)
            return data.map((car: any) => {
                 const primaryImage = car.images?.sort((a:any,b:any) => (a.sort_order ?? 0) - (b.sort_order ?? 0)).find((img: any) => img.is_primary) || car.images?.[0];
                  const price = car.pricing?.[0]?.base_price ?? car.pricing?.base_price;

                  return {
                     id: car.id,
                     slug: car.slug,
                     name: car.name,
                     // make: car.make, // Removed - Not fetched
                     // model: car.model, // Removed - Not fetched
                     category: car.category,
                     shortDescription: car.short_description,
                     isFeatured: car.featured, // Rename for consistency
                     primaryImageUrl: primaryImage?.url,
                     pricePerDay: price // Rename for consistency
                 };
             });

        } catch (error) {
            console.error("Error in getVisibleCarsForFleet:", error);
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred fetching visible cars for fleet");
        }
    },

     /**
     * Create a new car with related data using RPC for atomicity.
     */
    createCar: async (
        supabase: SupabaseClient,
        carData: AppCarUpsert,
        userId?: string | null // Optional user ID is no longer used by RPC
    ): Promise<AppCar> => {
        // Prepare arguments for the RPC function
        const rpcParams = {
            p_name: carData.name,
            p_category: carData.category,
            p_description: carData.description,
            p_short_description: carData.short_description,
            p_available: carData.available ?? true,
            p_featured: carData.featured ?? false,
            p_hidden: carData.hidden ?? false,
            p_pricing: carData.pricing, // Pass JSON directly
            p_images: carData.images, // Pass JSON array directly
            p_features: carData.features, // Pass JSON array directly
            p_specifications: carData.specifications // Pass JSON array directly
        };

        // ---- DEBUGGING: Log parameters being sent to RPC ----
        console.log("Calling create_car_atomic with params:", JSON.stringify(rpcParams, null, 2));
        // ----------------------------------------------------

        try {
            const { data: newCarId, error } = await supabase.rpc('create_car_atomic', rpcParams);

            if (error) {
                console.error("Error calling create_car_atomic RPC:", error);
                throw error; // Re-throw the specific error
            }

            if (!newCarId) {
                throw new Error("create_car_atomic RPC did not return a car ID.");
            }

            // Fetch the newly created car with all details to return the full AppCar object
            const newCar = await carServiceSupabase.getCarById(supabase, newCarId as string);
            if (!newCar) {
                throw new Error(`Failed to fetch newly created car with ID: ${newCarId}`);
            }
            return newCar;

        } catch (error) {
            // Handle potential errors during RPC call or subsequent fetch
             if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
             }
             throw new Error("An unexpected error occurred creating the car via RPC.");
        }
    },

     /**
     * Update a car and its related data using RPC for atomicity.
     * Handles deleting orphaned images from storage separately.
     */
    updateCar: async (
        supabase: SupabaseClient,
        carId: string,
        updates: Partial<AppCarUpsert> // Accept partial updates
    ): Promise<AppCar> => {

        // 1. Fetch existing image paths BEFORE the update RPC
        let existingImagePaths: string[] = [];
        try {
            const { data: images, error: imgError } = await supabase
                .from("car_images")
                .select("path")
                .eq("car_id", carId);
            if (imgError) throw new Error(`Failed to fetch existing image paths: ${imgError.message}`);
            existingImagePaths = images?.map(img => img.path).filter(Boolean) as string[] || [];
        } catch (error) {
            console.error("Error fetching existing image paths before update:", error);
            // Decide if we should proceed or throw - let's throw for now
            if (error instanceof Error) throw error; 
            throw new Error("Could not verify existing images before update.");
        }

        // 2. Prepare arguments for the RPC function
        // Need to merge updates with existing data or pass full objects
        // The RPC expects the *full* set of pricing, images, features, specs.
        // So we need the complete intended state, not just partial updates.
        // This logic assumes `updates` contains the *complete* desired state 
        // for related items (pricing, images, features, specifications).
        const rpcParams = {
            p_car_id: carId,
            // Base car fields (pass undefined if not present in updates)
            p_name: updates.name ?? undefined,
            p_category: updates.category ?? undefined,
            p_description: updates.description,
            p_short_description: updates.short_description,
            p_available: updates.available,
            p_featured: updates.featured,
            p_hidden: updates.hidden,
            // Related data (pass the full intended state)
            p_pricing: updates.pricing ?? null,
            p_images: updates.images ?? null, 
            p_features: updates.features ?? null,
            p_specifications: updates.specifications ?? null
        };

        // ---- DEBUGGING: Log parameters being sent to RPC ----
        console.log("Calling update_car_atomic with params:", JSON.stringify(rpcParams, null, 2));
        // ----------------------------------------------------

        try {
            // 3. Call the update RPC function
            const { error } = await supabase.rpc('update_car_atomic', rpcParams);

            if (error) {
                // ---- DEBUGGING: Log the specific RPC error ----
                console.error("Error calling update_car_atomic RPC:", error);
                // -------------------------------------------------
                throw error; // Re-throw specific error
            }

            // 4. Delete orphaned images from Storage
            const updatedImagePaths = new Set(updates.images?.map(img => img.path).filter(Boolean) as string[] || []);
            const pathsToDelete = existingImagePaths.filter(path => !updatedImagePaths.has(path));

            if (pathsToDelete.length > 0) {
                 console.log("Deleting orphaned images from storage:", pathsToDelete);
                 const { error: storageError } = await supabase.storage
                     .from(BUCKET_NAMES.VEHICLE_IMAGES)
                     .remove(pathsToDelete);
                 if (storageError) {
                     // Log error but don't necessarily fail the whole operation, 
                     // as DB update succeeded.
                     console.error("Failed to delete orphaned images from storage:", storageError);
                     // Optionally notify user/admin
                 }
            }

            // 5. Fetch the updated car data to return
            const updatedCar = await carServiceSupabase.getCarById(supabase, carId);
            if (!updatedCar) throw new Error(`Failed to fetch updated car ${carId} after update RPC.`);
            return updatedCar;

        } catch (error) {
            // Handle potential errors during RPC call or subsequent fetch/delete
             if (error instanceof Error) {
                // ---- DEBUGGING: Log the caught error before handling ----
                console.error("Caught error during updateCar process:", error);
                // -------------------------------------------------------
                throw new Error(handleSupabaseError(error));
             }
             // ---- DEBUGGING: Log unexpected error type ----
             console.error("Caught unexpected error type during updateCar:", error);
             // ----------------------------------------------
             throw new Error("An unexpected error occurred updating the car via RPC.");
        }
    },

    /**
     * Delete a car and its related data using RPC.
     * Handles deleting associated images from storage first.
     */
    deleteCar: async (supabase: SupabaseClient, carId: string): Promise<boolean> => {
        try {
            // 1. Get image paths to delete from storage BEFORE deleting DB record
            const { data: images, error: imgError } = await supabase
                .from("car_images")
                .select("path")
                .eq("car_id", carId);

             if (imgError) {
                 console.error("Failed to fetch images for deletion:", imgError);
                 throw imgError;
             }
             const imagePathsToDelete = images?.map(img => img.path).filter(Boolean) as string[] || [];

             // 2. Delete images from storage
             if (imagePathsToDelete.length > 0) {
                  const { error: storageError } = await supabase.storage
                    .from(BUCKET_NAMES.VEHICLE_IMAGES)
                    .remove(imagePathsToDelete);
                  if (storageError) {
                      // Log error but proceed with DB deletion attempt
                      console.error("Error deleting images from storage before DB delete:", storageError);
                  }
             }

             // 3. Call the delete RPC function (handles DB deletes via cascade)
             const { error: rpcError } = await supabase.rpc('delete_car_atomic', { p_car_id: carId });

             if (rpcError) {
                 console.error("Error calling delete_car_atomic RPC:", rpcError);
                 throw rpcError;
             }

            return true;
        } catch (error) {
            console.error(`Error deleting car ${carId}:`, error);
            if (error instanceof Error) {
                throw new Error(handleSupabaseError(error));
            }
            throw new Error("An unexpected error occurred deleting car via RPC");
        }
    },

     /**
      * Get unique categories for filtering (from visible cars)
      */
     getCategories: async (supabase: SupabaseClient): Promise<string[]> => {
         try {
             // Fetch distinct categories from visible cars
             // Using an RPC function might be more efficient if the table is large.
             const { data, error } = await supabase
                 .from("cars")
                 .select("category")
                 .eq("available", true)
                 .eq("hidden", false);

             if (error) throw error;
             if (!data) return [];

             const categories = data.map((item) => item.category as string);
             // Filter out null/empty, get unique, sort
             return Array.from(new Set(categories.filter(Boolean))).sort();
         } catch (error) {
             console.error("Error fetching categories:", error);
             if (error instanceof Error) {
                 throw new Error(handleSupabaseError(error));
             }
             throw new Error("An unexpected error occurred fetching categories");
         }
     },

     /**
      * Get related cars by category (for car detail page)
      */
     getRelatedCars: async (supabase: SupabaseClient, carId: string, limit = 3): Promise<any[]> => { // Return optimized list type
         try {
             // 1. Get the category of the current car
             const { data: currentCar, error: carError } = await supabase
                 .from("cars")
                 .select("category")
                 .eq("id", carId)
                 .maybeSingle();

             if (carError) {
                 console.error("Error fetching current car category for related cars:", carError);
                 throw carError; // Re-throw specific error
             }
             if (!currentCar?.category) return []; // No category or car not found

             // 2. Fetch related cars in the same category (optimized payload)
             const { data: relatedCars, error: relatedError } = await supabase
                 .from("cars")
                 .select(`
                     id,
                     slug,
                     name,
                     category,
                     pricing:car_pricing(base_price),
                     images:car_images(url, is_primary, sort_order)
                 `)
                 .eq("category", currentCar.category)
                 .neq("id", carId) // Exclude the current car
                 .eq("available", true)
                 .eq("hidden", false)
                 .limit(limit);

             if (relatedError) {
                 console.error("Error fetching related car details:", relatedError);
                 throw relatedError; // Re-throw specific error
             } 
             if (!relatedCars) return [];

             // Process data (similar to list views)
             return relatedCars.map((car: any) => {
                 const primaryImage = car.images?.sort((a:any,b:any) => (a.sort_order ?? 0) - (b.sort_order ?? 0)).find((img: any) => img.is_primary) || car.images?.[0];
                  const price = car.pricing?.[0]?.base_price ?? car.pricing?.base_price;
                  return {
                     id: car.id,
                     slug: car.slug,
                     name: car.name,
                     category: car.category,
                     primaryImageUrl: primaryImage?.url,
                     pricePerDay: price
                 };
             });

         } catch (error) {
             console.error("Error fetching related cars:", error);
             if (error instanceof Error) {
                 throw new Error(handleSupabaseError(error));
             }
             throw new Error("An unexpected error occurred fetching related cars");
         }
     },

}

// Helper function to generate slug (can be moved to utils)
function generateSlug(name: string): string {
    return name
        .toLowerCase()
        .replace(/\s+/g, '-')       // Replace spaces with -
        .replace(/[^\w-]+/g, '')    // Remove all non-word chars except -
        .replace(/--+/g, '-')       // Replace multiple - with single -
        .replace(/^-+/, '')          // Trim - from start of text
        .replace(/-+$/, '');         // Trim - from end of text
}

// Note: Assumed BUCKET_NAMES.VEHICLE_IMAGES exists and is correctly configured.
// Note: Assumed database types (`Database['public']['Tables']...`) are generated and accurate.
//       Run `npx supabase gen types typescript --project-id <your-project-id> --schema public > lib/types/database.types.ts` if needed.
// Note: Transactional integrity is NOT guaranteed by these separate calls. Use Supabase Edge Functions (RPC with pg_transaction) for atomic operations in production.

